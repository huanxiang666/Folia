<div align=center>
    <img src="./folia.png">
    <br /><br />
    <p>分支来自 <a href="https://github.com/PaperMC/Paper">Paper</a> 将区域化多线程添加到专用服务器.</p>
</div>

## 概述

Folia 将附近加载的块分组以形成一个“独立区域”。
请参阅 [REGION_LOGIC.md](REGION_LOGIC.md) 以了解有关 Folia 如何运行的确切详细信息
将附近的块分组。
每个独立的区域都有自己的滴答循环，在
常规 Minecraft 滴答速率 (20TPS)。 滴答循环被执行
在并行线程池上。 没有主线程了，
因为每个区域实际上都有自己的“主线程”来执行
整个滴答循环。

对于一个有很多分散玩家的服务器，Folia 会创建很多
展开区域并在可配置的大小上并行勾选它们
线程池。 因此，Folia 应该可以很好地适应这样的服务器。

Folia也是自己的项目，这个不会并入Paper
在可预见的未来。
更详细但抽象的概述：[项目概述](https://docs.papermc.io/folia/reference/overview)。
＃＃ 常问问题

### 哪些服务器类型可以从 Folia 中受益？
自然分散玩家的服务器类型，
像 skyblock 或 SMP，将从 Folia 中受益最多。 服务器
也应该有相当大的玩家数量。

### Folia 最适合在什么硬件上运行？
理想情况下，至少有 16 个核心（不是线程）。

### 如何最好地配置 Folia？
首先，建议世界是预先生成的，以便数量
所需的块系统工作线程数大大减少。

以下是基于测试的_非常粗略的_估计
在 Folia 在我们运行的测试服务器上发布之前完成
有大约 330 名玩家的峰值。 所以，它不准确，需要进一步调整 -
只是以此为起点。

机器上可用的内核总数应该是
考虑在内。 然后，分配线程：
- netty IO：每 200-300 名玩家约 4 个
- 块系统 io 线程：每 200-300 名玩家约 3 个
- 如果预先生成块系统工作人员，每 200-300 名玩家约 2 个
- 如果不是预先生成的，就没有对块系统工作者的最佳猜测，因为
   在我们运行的测试服务器上，我们给了 16 个线程，但块生成仍然是
   约 300 名玩家时速度较慢。
- GC 设置：???? 但是，GC 设置确实会分配并发线程，因此您需要
   知道到底有多少。 这通常是通过“-XX:ConcGCThreads=n”标志实现的。 不要
   将此标志与“-XX:ParallelGCThreads=n”混淆，因为并行 GC 线程仅在以下情况下运行
   该应用程序被 GC 暂停，因此不应考虑在内。

在所有分配之后，系统上剩余的核心直到 80%
分配（分配的总线程数 < 80% 可用的 CPU）可以是
分配给 tickthreads（在全局配置下，threaded-regions.threads）。

您不应分配超过 80% 的内核的原因是
事实上，插件甚至服务器可能会使用额外的线程
您无法配置甚至无法预测。

另外，以上都是根据玩家数量粗略猜测，但是
很可能线程分配不理想，而你
将需要根据您最终看到的线程的使用情况对其进行调整。## 插件兼容性

没有更多的主线程。 我期待_every_单个插件
存在需要_some_水平的修改功能
在福利亚。 此外，_any kind_的多线程引入了
插件保存数据中可能存在的竞争条件——因此，有约束
成为需要做出的改变。

因此，将您对兼容性的期望设为 0。

## API 计划

目前，有很多 API 依赖于主线程。
我希望与 Paper 兼容的插件基本上为零
与 Folia 兼容。 但是，有计划添加 API
将使 Folia 插件与 Paper 兼容。

例如，Bukkit 调度程序。 Bukkit Scheduler 本质上
依赖于单个主线程。 Folia 的 RegionScheduler 和 Folia 的
EntityScheduler 允许将任务安排到任何“下一个滴答”
区域“拥有”一个位置或一个实体。 这些可以实施
在普通纸上，除了他们安排到主线程 - 在这两种情况下，
任务的执行将发生在“拥有”
位置或实体。 这个概念一般适用，因为当前的论文
（单线程）可以被视为一个巨大的“区域”，它包含
所有世界中的所有块。

目前还没有决定是否直接将这个 API 添加到 Paper 本身
或到 Paperlib。

### 新规则

首先，Folia 破坏了许多插件。 帮助用户弄清楚哪个
插件工作，只有被明确标记的插件
将加载与 Folia 一起工作的作者。 放置
"folia-supported: true" 到插件的 plugin.yml，插件作者
可以将他们的插件标记为与区域化多线程兼容。

另一个重要的规则是区域在 _parallel_ 中勾选，而不是
_同时_。 他们不共享数据，他们不期望共享数据，
和共享数据_will_导致数据损坏。
任何情况下运行在一个区域的代码都不能
正在访问或修改位于另一个区域的数据。 只是
因为多线程在名称中，并不意味着一切
现在是线程安全的。 事实上，只有几件事情是
使线程安全以实现这一点。 随着时间的推移，数
线程上下文检查的数量只会增长，即使_if_它出现在
性能损失 - _nobody_ 会使用或开发
服务器平台漏洞百出，唯一的办法
防止和发现这些错误是使错误的访问在
不良访问的来源。

这意味着 Folia 兼容插件需要利用
像 RegionScheduler 和 EntityScheduler 这样的 API 来确保
他们的代码在正确的线程上下文中运行。

通常，假设一个区域拥有块数据是安全的
从事件源（即玩家）开始大约 8 个块
breaks 块，大概可以访问该块周围的 8 个块）。 但，
这不能保证 - 插件应该利用即将到来的
线程检查 API 以确保正确的行为。

线程安全的唯一保证来自于一个事实
单个区域拥有某些块中的数据 - 如果该区域是
滴答作响，那么它就可以完全访问该数据。 这个数据是
特别是实体/块/poi 数据，并且完全不相关
到**任何**插件数据。

正常的多线程规则适用于插件存储/访问的数据
他们自己的数据或另一个插件的 - 事件/命令/等。 叫做
在_parallel_因为区域在_parallel_滴答作响（我们不能
以同步方式调用它们，因为这会引发死锁问题
并且会妨碍性能）。 没有简单的方法可以解决这个问题，
它完全取决于正在访问的数据。 有时一个
并发集合（如 ConcurrentHashMap）就足够了，而且通常是
不小心使用并发集合只会_隐藏_线程
问题，然后几乎无法调试。
### 当前 API 添加

要正确理解 API 添加，请阅读
[PROJECT_DESCRIPTION.md](PROJECT_DESCRIPTION.md)。

- RegionScheduler、AsyncScheduler、GlobalRegionScheduler 和 EntityScheduler
   作为 BukkitScheduler 的替代品。
   实体调度程序通过 Entity#getScheduler 检索，并且
   其余的调度器可以从 Bukkit/Server 类中获取。
- Bukkit#isOwnedByCurrentRegion 测试当前滴答区域
   拥有职位/实体

### API 的线程上下文

要正确理解 API 添加，请阅读
[PROJECT_DESCRIPTION.md](PROJECT_DESCRIPTION.md)。

一般经验法则：

1.实体/玩家的命令在拥有的区域上调用
实体/玩家。 控制台命令在全局区域上执行。

2. 涉及单个实体的事件（即玩家休息/位置块）是
调用区域拥有实体。 涉及实体操作的事件
（例如实体损坏）在拥有目标实体的区域上调用。

3.事件的异步修饰符已弃用-所有事件
从区域或全球区域发射被认为是同步的，
即使不再有主线程。

### 当前损坏的 API

- 大多数与门户/重生玩家/一些交互的 API
   播放器登录 API 已损坏。
- 所有记分板 API 都被认为是坏的（这是全局状态
   我还没有想出如何正确实施）
- 世界加载/卸载
- 实体#teleport。 这将永远不会在任何情况下回来，
   使用 teleportAsync
- 可能更多

### 计划的 API 添加- 适当的异步事件。 这将允许事件的结果
   稍后在不同的线程上下文中完成。 这是必需的
   以异步方式实现诸如生成位置选择之类的东西
   在区域外访问块数据时需要块加载。
- 世界加载/卸载
- 更多来这里

### 计划的 API 更改

- 全面的超强线程检查。 这绝对是
   需要防止插件开发者发送可能随机的代码
   以完全_undiagnosable_方式破坏服务器的随机部分。
- 更多来这里

### Maven信息
* Maven 回购（用于 folia-api）：
```xml
<存储库>
     <id>纸片机</id>
     <url>https://repo.papermc.io/repository/maven-public/</url>
</存储库>
```
* 神器信息：
```xml
<依赖关系>
     <groupId>dev.folia</groupId>
     <artifactId>folia-api</artifactId>
     <版本>1.19.4-R0.1-快照</版本>
     <范围>提供</范围>
</依赖>
  ```


＃＃ 执照
PATCHES-LICENSE 文件描述了 api 和服务器补丁的许可证，
在 `./patches` 及其子目录中找到，除非另有说明。

该分叉基于 [此处](https://github.com/PaperMC/paperweight-examples) 中的 PaperMC 分叉示例。
因此，它包含在此项目中对其进行的修改，请参阅存储库以获取许可信息
的修改文件。
